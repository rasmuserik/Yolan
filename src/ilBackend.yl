[exports set [quote binaryEncode]
  [fn [tree acc]
    [def joinResult [acc fails]]
    [set acc [acc or [quote []]]]
    [acc push [String fromCharCode [tree get [quote length]]]]
    [if-else [Array isArray tree]
      [do [acc push [quote {]]
        [tree map [fn [elem] [exports binaryEncode elem acc]]]]
      [do [acc push [quote "]] [acc push tree]]]
    [joinResult and [acc join ""]]]]

[def hasValue [fn [val] [[this.indexOf(val) == -1] fails]]]

[exports set [quote toIL]
  [fn [ast]
    [def functions [quote []]]
    [def fnid 0]
    [def compileFunction
      [fn [name args ast]
        [def nextid 0]
        [args set [quote hasValue] hasValue]
        [def locals [quote []]]
        [locals set [quote hasValue] hasValue]
        [def globals [quote []]]
        [globals set [quote hasValue] hasValue]
        [def currentFunction [quote []]]
        [def compileExpression
          [fn [expr withArg]
            [def code [quote []]]
            [if [Array isArray expr]
              [def first [expr get 0]]
              [if [first == [quote #]]
                [return
                  [compileExpression call null [quote undefined] withArg]]]
              [if [first == [quote set]]
                [set code
                  [code concat
                    [compileExpression call null [expr get 2] true]]]
                [def name [expr get 1]]
                [if-else [args hasValue name]
                  [code push [new array [quote setArg] [expr get 1]]]
                  [if-else [locals hasValue name]
                    [code push [new array [quote setLocal] [expr get 1]]]
                    [do
                      [code push [new array [quote setGlobal] [expr get 1]]]
                      [if [[globals hasValue name] fails]
                        [globals push name]]]]]
                [if [withArg fails] [code push [quote [pop]]]]
                [return code]]
              [if [first == [quote def]]
                [locals push [expr get 1]]
                [set code
                  [code concat
                    [compileExpression call null [expr get 2] true]]]
                [code push [new array [quote setLocal] [expr get 1]]]
                [if [withArg fails] [code push [quote [pop]]]]
                [return code]]
              [if [first == [quote if-else]]
                [def label1 [nextid toString]]
                [set nextid [nextid + 1]]
                [def label2 [nextid toString]]
                [set nextid [nextid + 1]]
                [set code
                  [code concat
                    [compileExpression call null [expr get 1] true]]]
                [code push [new array [quote jumpIfFalsy] label1]]
                [set code
                  [code concat
                    [compileExpression call null [expr get 2] withArg]]]
                [code push [new array [quote jump] label2]]
                [code push [new array [quote label] label1]]
                [set code
                  [code concat
                    [compileExpression call null [expr get 3] withArg]]]
                [code push [new array [quote label] label2]]
                [return code]]
              [if [first == [quote fn]]
                [def id [[quote _] + fnid]]
                [set fnid [fnid + 1]]
                [def createdFunction
                  [compileFunction call null id
                    [expr get 1]
                    [[quote [do]] concat [expr slice 2]]]]
                [functions push createdFunction]
                [def i 0]
                [def fnGlobals [createdFunction get 4]]
                [while [i < [fnGlobals get [quote length]]]
                  [def globName [fnGlobals get i]]
                  [if [[globals hasValue globName] fails]
                    [globals push globName]]
                  [set i [i + 1]]]
                [return [new array [new array [quote fn] id]]]]
              [if [first == [quote do]]
                [def i 1]
                [def length [expr get [quote length]]]
                [while [i < length]
                  [set code
                    [code concat
                      [compileExpression call null
                        [expr get i]
                        [[i == [length - 1]] and withArg]]]]
                  [set i [i + 1]]]
                [return code]]
              [if true
                [def method [expr get 1]]
                [set expr [expr slice 1]]
                [expr set 0 first]
                [def types [expr map [fn [] [quote var]]]]
                [while [0 < [expr get [quote length]]]
                  [set code
                    [code concat
                      [compileExpression call null [expr pop] true]]]]
                [def invokeExpr [quote [invoke]]]
                [invokeExpr push method]
                [set invokeExpr [invokeExpr concat types]]
                [code push invokeExpr]
                [if [withArg fails] [code push [quote [pop]]]]
                [return code]]]
            [if [withArg fails] [return [quote []]]]
            [# look up var]
            [if [[[parseFloat call null expr] toString] == expr]
              [return [new array [new array [quote num] expr]]]]
            [def name expr]
            [if-else [args hasValue name]
              [code push [new array [quote getArg] name]]
              [if-else [locals hasValue name]
                [code push [new array [quote getLocal] name]]
                [do [code push [new array [quote getGlobal] name]]
                  [if [[globals hasValue name] fails] [globals push name]]]]]
            code]]
        [def code [compileExpression call null [ast slice 0] true]]
        [code push [quote [return]]]
        [currentFunction push name]
        [currentFunction push args]
        [currentFunction push locals]
        [currentFunction push globals]
        [currentFunction push code]
        currentFunction]]
    [functions push
      [compileFunction call null [quote entry] [quote []] ast]]
    functions]]
