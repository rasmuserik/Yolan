[# bug: double escaping needed - both for js-strings and yolan strings ]
[def tokenRegEx [RegExp call RegExp '\\\\s*(\\\\\[|\\\\\]|(\\\\\\\\.|\[^\\\\s\\\\\[\\\\\]\])+)' 'g']]

[def unescapeRegEx [RegExp call RegExp '\\\\\\\\(.)' 'g']]

[def yolan [object]]

[yolan set tokenize [fn [str]
    [def result [array]]
    [str replace tokenRegEx [fn [_ token]
        [result push token]]]
    result]]

[yolan set parse [fn [tokens]
    [set tokens [tokens reverse]]
    [def stack [array]]
    [def current [array 'do']]
    [while [tokens get 'length']
        [def token [tokens pop]]
        [cond
            [[eq? token '\[']
                [stack push current]
                [set current [array]]]
            [[eq? token '\]']
                [def t current]
                [set current [stack pop]]
                [current push t]]
            [true [current push [token replace unescapeRegEx [fn [_ a] a]]]]]]
    current]]

[def indent 0]
[yolan set nspace [fn [n]
    [def result [array]]
    [while [< 0 n] [set n [- n 1]] [result push '\ ']]
    [result join '']]]
    
[yolan set prettyprint [fn [ast]
    [def pos 0]
    [def width 78]
    [def indentStep 2]
    [def acc [array]]
    [def pp [fn [ast]
        [cond 
            [[eq? 'string' [JsTypeOf ast]] [acc push ast ]]
            [[Array isArray ast] 
                [def str [+ '\[' [[ast map yolan.prettyprint] join '\ ' ] '\]']]
                [set indent [+ indent 1]]
                [cond 
                  [[< [- width indent [str get 'length']] 0]
                    [acc push '\[']
                    [acc push [yolan prettyprint [ast get 0]]]
                    [acc push '\ ']
                    [acc push [[[ast slice 1] map yolan.prettyprint] join [+ '\\n' [yolan nspace indent]]]]
                    [acc push '\]']]
                  [true [acc push str]]]
                [set indent [- indent 1]]
            ]
        ]
        true
    ]]
    [pp call null ast]
    [acc join '']
]]

[def compileJS [object
    [JsTypeOf [fn [syn syn1] [+ 'typeof\ ' syn1]]]
    [do [fn [syn] [[[syn slice 1] map [yolan get 'toJS']] join ';']]]
    [def [fn [syn syn1] [+ 'var\ ' syn1 '=' [yolan toJS [syn get 2]]]]]
    [set [fn [syn syn1] [+ syn1 '=' [yolan toJS [syn get 2]]]]]
    [object [fn [syn syn1] [+ '{' 
        [[[syn slice 1] map [fn [pair] 
            [+ [JSON stringify [[pair get 0] toString]] ':' [yolan toJS [pair get 1]]]]]
        join ','] '}']]]
    [array [fn [syn syn1] [+ '\[' [[[syn slice 1] map [yolan get 'toJS']] join ',']'\]']]]
    [fn [fn [syn syn1] [+ 'function(' [syn1 join ','] '){' [[[syn slice 2 -1] map [yolan get 'toJS']] join ';'] ';return\ ' [yolan toJS [syn get [- [syn get 'length'] 1]]] '}']]]
    [while [fn [syn syn1] [+ 'while(' [yolan toJS syn1] '){' [[[syn slice 2] map [yolan get 'toJS']] join ';'] '}']]]
    [cond [fn [syn] 
        [[[syn slice 1] map 
            [fn [pair] [+
                'if(' 
                [yolan toJS [pair get 0]] 
                '){' 
                [[[pair slice 1] map [yolan get 'toJS']] join ';'] 
                '}']]] join 'else\ ']]]
     [# [fn [] '']]
     [return [fn [syn syn1] [+ 'return\ ' [yolan toJS syn1]]]]
     [throw [fn [syn syn1] [+ 'throw\ ' [yolan toJS syn1]]]]
     [+ [fn [syn] [[[syn slice 1] map [yolan get 'toJS']] join '+']]]
     [- [fn [syn] [[[syn slice 1] map [yolan get 'toJS']] join '-']]]
     [and [fn [syn] [[[syn slice 1] map [yolan get 'toJS']] join '&&']]]
     [or [fn [syn] [[[syn slice 1] map [yolan get 'toJS']] join '||']]]
     [not [fn [syn] [+ '!' [yolan toJS syn1]]]]
     [< [fn [syn syn1] [+ [yolan toJS syn1] '<' [yolan toJS [syn get 2]]]]]
     [<= [fn [syn syn1] [+ [yolan toJS syn1] '<=' [yolan toJS [syn get 2]]]]]
     [eq? [fn [syn syn1] [+ [yolan toJS syn1] '===' [yolan toJS [syn get 2]]]]]
]]

[yolan set toJS [fn [syn]
    [def syn0 [syn get 0]]
    [def syn1 [syn get 1]]
    [cond
        [[eq? [JsTypeOf syn] 'string'] [return syn]]
        [[compileJS get syn0] [return [[compileJS get syn0] call null syn syn1]]]
        [[eq? syn1 'set'] [return [+ [yolan toJS syn0] '.' [syn get 2] '=' [yolan toJS [syn get 3]]]]]
        [[eq? syn1 'get'] [return [+ [yolan toJS syn0] '\[' [yolan toJS [syn get 2]] '\]']]]
        [[eq? [JsTypeOf syn0] 'string'] [ return [+ [yolan toJS syn0] '.' syn1 '(' [[[syn slice 2] map [yolan get 'toJS']] join ','] ')']]]
    ]
    [+ [yolan toJS syn0] '.' syn1 '(' [[[syn slice 2] map [yolan get 'toJS']] join ','] ')']
]]

[def fs [require call null 'fs']]

[def action [[process get 'argv'] get 2]]

[cond 
    [[eq? action 'compile']
        [fs readFile [[process get 'argv'] get 3] 'utf8' [fn [err data]
            [cond [err [return err]]]
            [# compile yolan to js]
            [def js [yolan toJS [yolan parse [yolan tokenize data]]]]
            [# reformat js]
            [def uglify [require call null 'uglify-js']]
            [def jsp [uglify get 'parser']]
            [def pro [uglify get 'uglify']]
            [def ast [jsp parse js]]
            [set js [pro gen_code ast [object [beautify true]]]]
            [fs writeFile [[process get 'argv'] get 4] js [fn [err data] [cond [err [return err]]] true]]]]]
    [[eq? action 'prettyprint']
        [fs readFile [[process get 'argv'] get 3] 'utf8' [fn [err data]
            [cond [err [return err]]]
            [def ast [yolan parse [yolan tokenize data]]]
            [console log [yolan prettyprint ast]]
            true
        ]]
    ]
]
