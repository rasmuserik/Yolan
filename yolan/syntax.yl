[exports set 'tokenize
  [fn [str]
    [def result [array]]
    [def i 0]
    [def tokeniser [object]]
    [def c [str get 0]]
    [def nextc [fn [] [set i [i + 1]] [set c [str get i]] c]]
    [def isWs [fn [] [[c == '\ ] or [c == '\n] [c == '\r] [c == '\t]]]]
    [def isBracket [fn [] [[c == '\[] or [c == '\]]]]]
    [while c
      [while [isWs call] [nextc call]]
      [cond [[c == '\[] [result push lbracket] [nextc call]]
        [[c == '\]] [result push rbracket] [nextc call]]
        [[c == '\'] [result push quote] [nextc call]]
        [true [def symb ""]
          [while [c and [[isWs call] fails] [[isBracket call] fails]]
            [if [c == '\\]
              [do [nextc call]
                [if [[[isWs call] or [isBracket call] [c == '\']] fails]
                  [set symb [symb + '\\]]]]]
            [if [c == '"] [set symb [symb + '\\]]]
            [set symb [symb + c]]
            [nextc call]]
          [result push symb]]]]
    result]]

[def quote [object ['quote true]]]

[def lbracket [object ['lbracket true]]]

[def rbracket [object ['rbracket true]]]

[def addQuotes
  [fn [list]
    [def i 0]
    [def result [array]]
    [while [i < [list get 'length]]
      [def elem [list get i]]
      [if [elem == quote]
        [do [set i [i + 1]] [set elem [array 'quote [list get i]]]]]
      [result push elem]
      [set i [i + 1]]]
    result]]

[exports set 'parse
  [fn [tokens]
    [set tokens [tokens reverse]]
    [def stack [array]]
    [def current [array 'do]]
    [while [tokens get 'length]
      [def token [tokens pop]]
      [cond [[token == lbracket] [stack push current] [set current [array]]]
        [[token == rbracket] [def t current]
          [set current [stack pop]]
          [current push [addQuotes call null t]]]
        [[token == quote] [current push quote]]
        [true [current push [JSON parse ['" + token '"]]]]]]
    current]]

[exports set 'nspace
  [fn [n]
    [def result [array]]
    [while [0 < n] [set n [n - 1]] [result push '\ ]]
    [result join ""]]]

[def indent 0]

[def screenWidth 78]

[def indentStep 2]

[def escapeRegEx [RegExp call RegExp '\[\'\ \\\[\\\]\] 'g]]

[def escapeRegEx2 [RegExp call RegExp '\\\\" 'g]]

[exports set 'prettyprint
  [fn [ast]
    [if [[ast jsType] == 'string]
      [return
        [[[[JSON stringify ast] slice 1 -1] replace escapeRegEx
            [fn [s] ['\\ + s]]]
          replace escapeRegEx2 '"]]]
    [if [[2 == [ast get 'length]] and ['quote == [ast get 0]]]
      [return ['\' + [exports prettyprint [ast get 1]]]]]
    [if [0 == [ast get 'length]] [return '\[\]]]
    [set indent [indent + indentStep]]
    [def pos indent]
    [set strs [ast map [exports get 'prettyprint]]]
    [if [[pos + [[strs join] get 'length] 1] < screenWidth]
      [do [set indent [indent - indentStep]]
        [return ['\[ + [strs join '\ ] '\]]]]]
    [def space ['\n + [exports nspace indent]]]
    [def result [array]]
    [result push '\[]
    [result push [strs get 0]]
    [set pos [pos + [[strs get 0] get 'length] 1]]
    [def i 1]
    [def forceNewLine false]
    [def currentIsString true]
    [while [i < [ast get 'length]]
      [def prevIsString currentIsString]
      [set currentIsString
        [[[[ast get i] jsType] == 'string] or
          ['quote == [[ast get i] get 0]]]]
      [set forceNewLine false]
      [if [[prevIsString fails] or [currentIsString fails]]
        [set forceNewLine true]]
      [if [i < 2] [set forceNewLine false]]
      [def prevIsString currentIsString]
      [result push '\ ]
      [if
        [forceNewLine or [screenWidth < [pos + [[strs get i] get 'length]]]]
        [do [result pop] [result push space] [set pos indent]]]
      [result push [strs get i]]
      [set pos [pos + [[strs get i] get 'length] 1]]
      [set i [i + 1]]]
    [result push '\]]
    [set indent [indent - indentStep]]
    [result join ""]]]

