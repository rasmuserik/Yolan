[exports set 'tokenize
  [fn [str]
    [def result [array]]
    [def i 0]
    [def tokeniser [object]]
    [def c [str get 0]]
    [def nextc [fn [] [set i [+ i 1]] [set c [str get i]] c]]
    [def isWs [fn [] [or [eq? c '\ ] [eq? c '\n] [eq? c '\r] [eq? c '\t]]]]
    [def isBracket [fn [] [or [eq? c '\[] [eq? c '\]]]]]
    [while c
      [while [isWs call] [nextc call]]
      [cond [[eq? c '\[] [result push lbracket] [nextc call]]
        [[eq? c '\]] [result push rbracket] [nextc call]]
        [[eq? c '\'] [result push quote] [nextc call]]
        [true [def symb ""]
          [while [and c [not [isWs call]] [not [isBracket call]]]
            [if [eq? c '\\]
              [nextc call]
              [if [not [or [isWs call] [isBracket call] [eq? c '\']]]
                [set symb [+ symb '\\]]]]
            [if [eq? c '"] [set symb [+ symb '\\]]]
            [set symb [+ symb c]]
            [nextc call]]
          [result push symb]]]]
    result]]

[def quote [object ['quote true]]]

[def lbracket [object ['lbracket true]]]

[def rbracket [object ['rbracket true]]]

[def addQuotes
  [fn [list]
    [def i 0]
    [def result [array]]
    [while [< i [list get 'length]]
      [def elem [list get i]]
      [if [eq? elem quote]
        [set i [+ i 1]]
        [set elem [array 'quote [list get i]]]]
      [result push elem]
      [set i [+ i 1]]]
    result]]

[exports set 'parse
  [fn [tokens]
    [set tokens [tokens reverse]]
    [def stack [array]]
    [def current [array 'do]]
    [while [tokens get 'length]
      [def token [tokens pop]]
      [cond [[eq? token lbracket] [stack push current] [set current [array]]]
        [[eq? token rbracket] [def t current]
          [set current [stack pop]]
          [current push [addQuotes call null t]]]
        [[eq? token quote] [current push quote]]
        [true [current push [JSON parse [+ '" token '"]]]]]]
    current]]

[exports set 'nspace
  [fn [n]
    [def result [array]]
    [while [< 0 n] [set n [- n 1]] [result push '\ ]]
    [result join ""]]]

[def indent 0]

[def screenWidth 78]

[def indentStep 2]

[def escapeRegEx [RegExp call RegExp '\[\'\ \\\[\\\]\] 'g]]

[def escapeRegEx2 [RegExp call RegExp '\\\\" 'g]]

[exports set 'prettyprint
  [fn [ast]
    [if [eq? [JsTypeOf ast] 'string]
      [return
        [[[[JSON stringify ast] slice 1 -1] replace escapeRegEx
            [fn [s] [+ '\\ s]]]
          replace escapeRegEx2 '"]]]
    [if [and [eq? 2 [ast get 'length]] [eq? 'quote [ast get 0]]]
      [return [+ '\' [exports prettyprint [ast get 1]]]]]
    [if [eq? 0 [ast get 'length]] [return '\[\]]]
    [set indent [+ indent indentStep]]
    [def pos indent]
    [set strs [ast map [exports get 'prettyprint]]]
    [if [< [+ pos [[strs join] get 'length] 1] screenWidth]
      [set indent [- indent indentStep]]
      [return [+ '\[ [strs join '\ ] '\]]]]
    [def space [+ '\n [exports nspace indent]]]
    [def result [array]]
    [result push '\[]
    [result push [strs get 0]]
    [set pos [+ pos [[strs get 0] get 'length] 1]]
    [def i 1]
    [def forceNewLine false]
    [def currentIsString true]
    [while [< i [ast get 'length]]
      [def prevIsString currentIsString]
      [set currentIsString
        [or [eq? [JsTypeOf [ast get i]] 'string]
          [eq? 'quote [[ast get i] get 0]]]]
      [set forceNewLine false]
      [if [or [not prevIsString] [not currentIsString]]
        [set forceNewLine true]]
      [if [< i 2] [set forceNewLine false]]
      [def prevIsString currentIsString]
      [result push '\ ]
      [if
        [or forceNewLine [< screenWidth [+ pos [[strs get i] get 'length]]]]
        [result pop]
        [result push space]
        [set pos indent]]
      [result push [strs get i]]
      [set pos [+ pos [[strs get i] get 'length] 1]]
      [set i [+ i 1]]]
    [result push '\]]
    [set indent [- indent indentStep]]
    [result join ""]]]

